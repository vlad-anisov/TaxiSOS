package com.example.sostaxi

import android.content.Context
import android.content.*
import android.media.MediaScannerConnection
import androidx.appcompat.app.AppCompatActivity
import android.util.Log
import android.widget.*
import android.widget.AdapterView
import kotlinx.coroutines.*
import com.google.android.gms.location.LocationServices
import com.google.android.gms.tasks.Task
import com.google.android.gms.location.Priority
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.asRequestBody
import com.pedro.library.view.OpenGlView
import com.pedro.library.rtmp.RtmpCamera2
import com.pedro.encoder.input.gl.render.filters.CropFilterRender
import com.pedro.common.ConnectChecker
import com.pedro.encoder.utils.gl.AspectRatioMode
import java.io.File
import java.text.SimpleDateFormat
import java.util.*
import kotlinx.coroutines.suspendCancellableCoroutine
import android.view.View
import android.content.res.Configuration
import android.os.Bundle
import android.app.ProgressDialog


class MainActivity : AppCompatActivity(), ConnectChecker {

    private val root by lazy { findViewById<View>(android.R.id.content) }
    private lateinit var startStopButton: Button
    private lateinit var settingsButton: Button
    private lateinit var modeSwitch: Spinner
    private lateinit var openGlView: OpenGlView
    private var rtmpCamera: RtmpCamera2? = null
    // Добавляем класс для хранения данных канала
    data class ChannelInfo(val name: String, val url: String, val key: String)
    // Список каналов
    private val channelsList = mutableListOf<ChannelInfo>()
    
    // Новые поля для Telegram авторизации и данных пользователя
    private var telegramUserId: Long? = null
    private var telegramUserName: String? = null
    private var telegramUserPhone: String? = null
    private var telegramContacts = mutableListOf<TelegramContact>()
    private var selectedContacts = mutableListOf<TelegramContact>()
    
    // Класс для хранения контактов из Telegram
    data class TelegramContact(
        val id: Long,
        val name: String,
        val phone: String,
        var isSelected: Boolean = false
    )
    
    // Информация о пользователе
    private var userName: String = ""
    private var userCar: String = ""
    private var userCarColor: String = ""
    
    enum class WorkMode {
        VIDEO_SEGMENTS,     // Отправка видео сегментами
        RTMP_STREAMING      // Настоящая RTMP-трансляция
    }
    private var currentWorkMode = WorkMode.RTMP_STREAMING
    private var rtmpUrl: String = ""
    private var rtmpStreamKey: String = ""
    private var fullRtmpUrl: String = ""
    // URL Google Таблицы в CSV формате
    private val SPREADSHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vR2CksjoEO6pzSaz0FY6fhBSAIjXn9gCCGsMCVG7sPsRAh54FvuLmxn_2eQh6QCOBK9PsNGn6-06QZU/pub?output=csv"
    
    companion object {
        @Volatile var isActive: Boolean = false
        const val ACTION_STOP_RECORDING = "com.example.sostaxi.ACTION_STOP_RECORDING"
        const val TELEGRAM_BOT_TOKEN = "7960834986:AAGr7DfkvN2cRi2FWWqKMVhbmIbu9li6SFE"
        const val TELEGRAM_CHAT_ID = "-4706227781"
        
        // Добавляем константы для запроса разрешений
        private const val PERMISSION_REQUEST_CODE = 1001
        private const val TELEGRAM_AUTH_PERMISSION_REQUEST_CODE = 1002
    }
    private val ioScope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    private var liveLocationMessageId: Int? = null
    // BroadcastReceiver для сигнала остановки (от Quick Settings плитки)
    private val stopReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            if (intent?.action == ACTION_STOP_RECORDING) {
                // Остановка записи по сигналу (например, повторное нажатие плитки QS)
                stop()
            }
        }
    }

    // Добавим свойство для телеграм-авторизации в класс MainActivity (временно отключено)
    // private lateinit var telegramAuthHelper: TelegramAuthHelper

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        loadRtmpSettings()
        
        // Тестируем новую официальную TDLib
        testOfficialTdLib()
        
        // Инициализируем помощник авторизации Telegram (временно отключено для тестирования новой TDLib)
        // telegramAuthHelper = TelegramAuthHelper(this)
        // Инициализируем TelegramAuthHelper только один раз
        // initializeTelegramAuth()
        
        val layout = FrameLayout(this)
        val previewParams = FrameLayout.LayoutParams(1, 1)
        previewParams.gravity = android.view.Gravity.TOP or android.view.Gravity.START

        openGlView = OpenGlView(this)
        openGlView.setAspectRatioMode(AspectRatioMode.Adjust)
        openGlView.visibility = View.VISIBLE
        rtmpCamera = RtmpCamera2(openGlView, this)
        rtmpCamera?.switchCamera()
        layout.addView(openGlView, previewParams)

        startStopButton = Button(this)
        startStopButton.text = "Старт"
        startStopButton.isAllCaps = false
        val btnParams = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT
        )
        btnParams.gravity = android.view.Gravity.CENTER or android.view.Gravity.BOTTOM
        btnParams.bottomMargin = 200
        layout.addView(startStopButton, btnParams)

        // Добавляем кнопку "Настройки"
        settingsButton = Button(this)
        settingsButton.text = "Настройки"
        settingsButton.isAllCaps = false
        val settingsBtnParams = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT
        )
        settingsBtnParams.gravity = android.view.Gravity.CENTER or android.view.Gravity.BOTTOM
        settingsBtnParams.bottomMargin = 50 // Позиционируем под кнопкой Старт/Стоп
        layout.addView(settingsButton, settingsBtnParams)

        setContentView(layout)

        // Назначаем обработчик для кнопки настроек
        settingsButton.setOnClickListener {
            showSettingsDialog()
        }

        // Регистрируем ресивер для остановки записи (сигнал от QS плитки)
        registerReceiver(stopReceiver, IntentFilter(ACTION_STOP_RECORDING), Context.RECEIVER_NOT_EXPORTED)

        startStopButton.setOnClickListener {
            if (!isActive) {
                start()
            } else {
                stop()
            }
        }

        // Если активность запущена из плитки QS с намерением начать запись сразу
        if (intent?.getBooleanExtra("startImmediately", false) == true) {
            startStopButton.post { startStopButton.performClick() }
        }
    }

    private fun showSettingsDialog() {
        val dialogLayout = LinearLayout(this)
        dialogLayout.orientation = LinearLayout.VERTICAL
        dialogLayout.setPadding(50, 30, 50, 30)

        // Объявляем переменную dialog заранее
        lateinit var dialog: androidx.appcompat.app.AlertDialog

        // Добавляем заголовок "Режим работы"
        val modeLabel = TextView(this)
        modeLabel.text = "Режим работы"
        modeLabel.textSize = 16f
        modeLabel.setPadding(0, 0, 0, 10)
        dialogLayout.addView(modeLabel)

        // Создаем новый Spinner для выбора режима
        val modeSpinner = Spinner(this)
        val adapter = ArrayAdapter.createFromResource(
            this,
            R.array.work_modes,
            android.R.layout.simple_spinner_item
        )
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        modeSpinner.adapter = adapter
        
        // Устанавливаем текущий выбранный режим
        modeSpinner.setSelection(if (currentWorkMode == WorkMode.VIDEO_SEGMENTS) 0 else 1)
        dialogLayout.addView(modeSpinner)

        // Добавляем разделитель
        val divider = View(this)
        divider.setBackgroundColor(0x20000000)
        val dividerParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 2
        )
        dividerParams.setMargins(0, 30, 0, 30)
        dialogLayout.addView(divider, dividerParams)

        // Добавляем заголовок "Канал трансляции"
        val channelLabel = TextView(this)
        channelLabel.text = "Канал трансляции"
        channelLabel.textSize = 16f
        channelLabel.setPadding(0, 0, 0, 10)
        dialogLayout.addView(channelLabel)
        
        // Создаем элемент для отображения текущего канала
        val channelInfoContainer = LinearLayout(this)
        channelInfoContainer.orientation = LinearLayout.HORIZONTAL
        channelInfoContainer.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        // Текущий канал (или сообщение, если канал не выбран)
        val currentChannelText = TextView(this)
        currentChannelText.layoutParams = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f
        )
        
        // Определяем текущий канал
        val currentChannelName = if (rtmpUrl.isEmpty() || rtmpStreamKey.isEmpty()) {
            "Канал не выбран"
        } else {
            // Пытаемся найти имя канала по сохраненным url и key
            val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
            sharedPrefs.getString("channel_name", "Неизвестный канал")
        }
        
        currentChannelText.text = currentChannelName
        currentChannelText.textSize = 14f
        
        // Значок выбора (только текст "Изменить" без стрелки)
        val selectIcon = TextView(this)
        selectIcon.text = "Изменить"
        selectIcon.textSize = 14f
        
        // Добавляем элементы в контейнер
        channelInfoContainer.addView(currentChannelText)
        channelInfoContainer.addView(selectIcon)
        
        // Делаем весь контейнер кликабельным
        channelInfoContainer.isClickable = true
        channelInfoContainer.isFocusable = true
        
        // Добавляем фон с эффектом при нажатии
        val outValue = android.util.TypedValue()
        theme.resolveAttribute(android.R.attr.selectableItemBackground, outValue, true)
        channelInfoContainer.setBackgroundResource(outValue.resourceId)
        
        dialogLayout.addView(channelInfoContainer)
        
        // Добавляем разделитель
        val divider2 = View(this)
        divider2.setBackgroundColor(0x20000000)
        val divider2Params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 2
        )
        divider2Params.setMargins(0, 30, 0, 30)
        dialogLayout.addView(divider2, divider2Params)
        
        // Добавляем заголовок "Telegram авторизация"
        val telegramLabel = TextView(this)
        telegramLabel.text = "Telegram авторизация"
        telegramLabel.textSize = 16f
        telegramLabel.setPadding(0, 0, 0, 10)
        dialogLayout.addView(telegramLabel)
        
        // Добавляем переключатель типа серверов
        val serverTypeContainer = LinearLayout(this)
        serverTypeContainer.orientation = LinearLayout.HORIZONTAL
        serverTypeContainer.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        val serverTypeLabel = TextView(this)
        serverTypeLabel.text = "Тип серверов: "
        serverTypeLabel.textSize = 14f
        serverTypeLabel.layoutParams = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f
        )
        
        val serverTypeSpinner = Spinner(this)
        val serverTypes = arrayOf("Продакшн", "Тестовые")
        val serverAdapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, serverTypes)
        serverAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        serverTypeSpinner.adapter = serverAdapter
        
        // Устанавливаем текущий выбранный тип серверов
        serverTypeSpinner.setSelection(if (telegramAuthHelper.isUsingTestServers()) 1 else 0)
        
        serverTypeContainer.addView(serverTypeLabel)
        serverTypeContainer.addView(serverTypeSpinner)
        dialogLayout.addView(serverTypeContainer)
        
        // Добавляем описание типов серверов
        val serverDescriptionText = TextView(this)
        serverDescriptionText.textSize = 12f
        serverDescriptionText.setPadding(0, 5, 0, 15)
        if (telegramAuthHelper.isUsingTestServers()) {
            serverDescriptionText.text = "Тестовые серверы: используйте номера +9996612222, +9996612223, +9996612224"
        } else {
            serverDescriptionText.text = "Продакшн серверы: используйте реальные номера телефонов"
        }
        dialogLayout.addView(serverDescriptionText)
        
        // Обработчик изменения типа серверов
        serverTypeSpinner.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
                val useTestServers = position == 1
                telegramAuthHelper.setUseTestServers(useTestServers)
                
                // Обновляем описание
                if (useTestServers) {
                    serverDescriptionText.text = "Тестовые серверы: используйте номера +9996612222, +9996612223, +9996612224"
                } else {
                    serverDescriptionText.text = "Продакшн серверы: используйте реальные номера телефонов"
                }
            }
            
            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
        
        // Получаем текущие данные пользователя
        val currentUser = telegramAuthHelper.getCurrentUserInfo()
        
        // Если пользователь авторизован - показываем информацию о нем
        if (currentUser != null) {
            // Информация о текущем пользователе
            val userInfoText = TextView(this)
            val displayName = buildString {
                append(currentUser.first_name)
                currentUser.last_name?.let { append(" $it") }
                currentUser.username?.let { append(" (@$it)") }
            }
            userInfoText.text = "Авторизован как: $displayName"
            userInfoText.textSize = 14f
            userInfoText.setPadding(0, 0, 0, 10)
            dialogLayout.addView(userInfoText)
            
            // Кнопка "Показать информацию о пользователе"
            val userInfoButton = Button(this)
            userInfoButton.text = "Информация о пользователе"
            userInfoButton.isAllCaps = false
            dialogLayout.addView(userInfoButton)
            
            userInfoButton.setOnClickListener {
                TelegramAuthDialogs.showUserInfoDialog(this@MainActivity, currentUser)
            }
            
            // Кнопка "Войти в другой аккаунт Telegram"
            val changeAccountButton = Button(this)
            changeAccountButton.text = "Войти в другой аккаунт Telegram"
            changeAccountButton.isAllCaps = false
            dialogLayout.addView(changeAccountButton)
            
            changeAccountButton.setOnClickListener {
                // Сначала выходим из текущего аккаунта, потом запускаем новую авторизацию
                logoutFromTelegram()
                dialog.dismiss() // Закрываем текущий диалог
            }
            
            // Добавляем заголовок "Выбранные контакты"
            if (selectedContacts.isNotEmpty()) {
                val contactsLabel = TextView(this)
                contactsLabel.text = "Выбранные контакты: ${selectedContacts.size}"
                contactsLabel.textSize = 16f
                contactsLabel.setPadding(0, 10, 0, 10)
                dialogLayout.addView(contactsLabel)
                
                // Контейнер для списка выбранных контактов
                val contactsContainer = LinearLayout(this)
                contactsContainer.orientation = LinearLayout.VERTICAL
                contactsContainer.layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT
                )
                
                // Добавляем первые 3 контакта (или меньше, если выбрано меньше)
                val displayCount = minOf(3, selectedContacts.size)
                for (i in 0 until displayCount) {
                    val contact = selectedContacts[i]
                    val contactText = TextView(this)
                    contactText.text = contact.name
                    contactText.textSize = 14f
                    contactText.setPadding(10, 5, 0, 5)
                    contactsContainer.addView(contactText)
                }
                
                // Если выбрано больше 3 контактов, показываем "И еще X"
                if (selectedContacts.size > 3) {
                    val moreText = TextView(this)
                    moreText.text = "И еще ${selectedContacts.size - 3}..."
                    moreText.textSize = 14f
                    moreText.setPadding(10, 5, 0, 5)
                    contactsContainer.addView(moreText)
                }
                
                dialogLayout.addView(contactsContainer)
            }
            
            // Кнопка выбора контактов
            val selectContactsButton = Button(this)
            selectContactsButton.text = if (selectedContacts.isEmpty()) "Выбрать контакты" else "Изменить выбор контактов"
            selectContactsButton.isAllCaps = false
            dialogLayout.addView(selectContactsButton)
            
            selectContactsButton.setOnClickListener {
                showContactsSelectionDialog()
            }
        } else {
            // Кнопка "Войти через Telegram"
            val loginButton = Button(this)
            loginButton.text = "Войти через Telegram"
            loginButton.isAllCaps = false
            dialogLayout.addView(loginButton)
            
            loginButton.setOnClickListener {
                // Запускаем полноценную авторизацию через Telegram OAuth
                startTelegramAuth()
            }
        }
        
        // Добавляем разделитель
        val divider3 = View(this)
        divider3.setBackgroundColor(0x20000000)
        val divider3Params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 2
        )
        divider3Params.setMargins(0, 30, 0, 30)
        dialogLayout.addView(divider3, divider3Params)
        
        // Добавляем заголовок "Информация о пользователе"
        val userInfoLabel = TextView(this)
        userInfoLabel.text = "Информация о пользователе"
        userInfoLabel.textSize = 16f
        userInfoLabel.setPadding(0, 0, 0, 10)
        dialogLayout.addView(userInfoLabel)
        
        // Загружаем сохраненные данные
        val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
        userName = sharedPrefs.getString("user_name", "") ?: ""
        userCar = sharedPrefs.getString("user_car", "") ?: ""
        userCarColor = sharedPrefs.getString("user_car_color", "") ?: ""
        
        // Поле для ввода имени
        val nameLabel = TextView(this)
        nameLabel.text = "Имя:"
        nameLabel.textSize = 14f
        dialogLayout.addView(nameLabel)
        
        val nameInput = EditText(this)
        nameInput.setText(userName)
        nameInput.hint = "Введите ваше имя"
        dialogLayout.addView(nameInput)
        
        // Поле для ввода марки машины
        val carLabel = TextView(this)
        carLabel.text = "Машина:"
        carLabel.textSize = 14f
        carLabel.setPadding(0, 10, 0, 0)
        dialogLayout.addView(carLabel)
        
        val carInput = EditText(this)
        carInput.setText(userCar)
        carInput.hint = "Введите марку и модель машины"
        dialogLayout.addView(carInput)
        
        // Поле для ввода цвета машины
        val colorLabel = TextView(this)
        colorLabel.text = "Цвет машины:"
        colorLabel.textSize = 14f
        colorLabel.setPadding(0, 10, 0, 0)
        dialogLayout.addView(colorLabel)
        
        val colorInput = EditText(this)
        colorInput.setText(userCarColor)
        colorInput.hint = "Введите цвет машины"
        dialogLayout.addView(colorInput)
        
        // Создаем и отображаем диалог с кнопкой "Готово" по центру
        dialog = androidx.appcompat.app.AlertDialog.Builder(this)
            .setTitle("Настройки")
            .setView(dialogLayout)
            .setPositiveButton("Готово") { _, _ ->
                // Сохраняем выбранный режим
                currentWorkMode = when (modeSpinner.selectedItemPosition) {
                    0 -> WorkMode.VIDEO_SEGMENTS
                    1 -> WorkMode.RTMP_STREAMING
                    else -> WorkMode.RTMP_STREAMING
                }
                
                // Сохраняем информацию о пользователе
                userName = nameInput.text.toString().trim()
                userCar = carInput.text.toString().trim()
                userCarColor = colorInput.text.toString().trim()
                
                // Сохраняем в SharedPreferences
                val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
                sharedPrefs.edit()
                    .putString("user_name", userName)
                    .putString("user_car", userCar)
                    .putString("user_car_color", userCarColor)
                    .apply()
            }
            .create()
        
        // Центрирование заголовка диалога
        dialog.setOnShowListener {
            val titleView = dialog.findViewById<TextView>(androidx.appcompat.R.id.alertTitle)
            titleView?.gravity = android.view.Gravity.CENTER
            
            // Центрирование кнопок
            val positiveButton = dialog.getButton(androidx.appcompat.app.AlertDialog.BUTTON_POSITIVE)
            val layoutParams = positiveButton.layoutParams as LinearLayout.LayoutParams
            layoutParams.gravity = android.view.Gravity.CENTER
            layoutParams.width = LinearLayout.LayoutParams.WRAP_CONTENT
            positiveButton.layoutParams = layoutParams
            
            // Перемещение кнопки в центр
            val buttonLayout = positiveButton.parent as LinearLayout
            buttonLayout.gravity = android.view.Gravity.CENTER
        }

        // Настраиваем действие для элемента выбора канала
        channelInfoContainer.setOnClickListener {
            dialog.dismiss()
            showRtmpSettingsDialog(true) // Передаем флаг, указывающий, что нужно вернуться в основное меню
        }
        
        dialog.show()
    }

    private fun start() {
        if (isActive) return
        isActive = true
        when (currentWorkMode) {
            WorkMode.VIDEO_SEGMENTS -> {
                startRecord()
            }
            WorkMode.RTMP_STREAMING -> {
                startStream()
            }
        }
//        startLiveLocation()
        startStopButton.text = "Стоп"
        enterPictureInPictureMode()
    }

    private fun stop() {
        if (!isActive) return
        isActive = false
//        sendLiveLocation()
        liveLocationMessageId = null
        rtmpCamera?.stopStream()
        rtmpCamera?.stopRecord()
        startStopButton.text = "Старт"
    }

    private fun startStream() {
        if (fullRtmpUrl.isEmpty()) {
            showRtmpSettingsDialog()
            return
        }
        try {
            rtmpCamera?.prepareAudio(192 * 1024, 44_100, true)
            rtmpCamera?.prepareVideo(1280, 720, 30, 2_000 * 1024, 90)
            rtmpCamera?.getGlInterface()?.setFilter(CropFilterRender().apply {
                setCropArea(0f, 33.33f, 99.99f, 33.33f)
            })
            rtmpCamera?.startStream(fullRtmpUrl)
            if (rtmpCamera?.isStreaming == true) {
                startStopButton.text = "Стоп"
            }
        } catch (e: Exception) {
            Log.e("MainActivity", "Критическая ошибка при инициализации RTMP: ${e.message}")
        }
    }

    private fun startRecord() {
        ioScope.launch {
            while (MainActivity.isActive) {
                try {
                    val ts = SimpleDateFormat("yyyyMMdd_HH-mm-ss", Locale.US).format(System.currentTimeMillis())
                    val file = File(getExternalFilesDir(null), "taxi_sos_${ts}.mp4")
                    rtmpCamera?.prepareAudio(192 * 1024, 44_100, true)
                    rtmpCamera?.prepareVideo(1280, 720, 30, 2_000 * 1024, 90)
                    rtmpCamera?.startRecord(file.absolutePath)
                    delay(10_000)
                    rtmpCamera?.stopRecord()
                    MediaScannerConnection.scanFile(this@MainActivity, arrayOf(file.absolutePath),null,null)
                    sendVideo(file)
                } catch (e: Exception) {
                    Log.e("MainActivity", "stopRecord() failed: ${e.message}")
                }
            }
        }
    }

    private fun sendVideo(videoFile: File) {
        ioScope.launch {
            try {
                // Формируем информационное сообщение о пользователе
                var userInfoMessage = ""
                if (telegramUserId != null) {
                    userInfoMessage += "Пользователь Telegram: $telegramUserName\n"
                }
                if (userName.isNotEmpty()) {
                    userInfoMessage += "Имя: $userName\n"
                }
                if (userCar.isNotEmpty()) {
                    userInfoMessage += "Машина: $userCar\n"
                }
                if (userCarColor.isNotEmpty()) {
                    userInfoMessage += "Цвет: $userCarColor\n"
                }
                
                // Отправляем информационное сообщение, если оно не пустое
                if (userInfoMessage.isNotEmpty()) {
                    val captionBody = MultipartBody.Builder().setType(MultipartBody.FORM)
                        .addFormDataPart("chat_id", TELEGRAM_CHAT_ID)
                        .addFormDataPart("text", userInfoMessage)
                        .build()
                    
                    val captionUrl = "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"
                    val captionRequest = Request.Builder()
                        .url(captionUrl)
                        .post(captionBody)
                        .build()
                    
                    OkHttpClient().newCall(captionRequest).execute().close()
                }
                
                // Отправляем видео
                val videoRequestBody = videoFile.asRequestBody("video/mp4".toMediaTypeOrNull())
                val multipartBody = MultipartBody.Builder().setType(MultipartBody.FORM)
                    .addFormDataPart("chat_id", TELEGRAM_CHAT_ID)
                    .addFormDataPart("video", videoFile.name, videoRequestBody)
                    .build()
                val url = "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendVideo"
                val request = Request.Builder()
                    .url(url)
                    .post(multipartBody)
                    .build()

                val client = OkHttpClient.Builder()
                    .connectTimeout(60, java.util.concurrent.TimeUnit.SECONDS)
                    .writeTimeout(60, java.util.concurrent.TimeUnit.SECONDS)
                    .readTimeout(60, java.util.concurrent.TimeUnit.SECONDS)
                    .build()
                val response = client.newCall(request).execute()
                if (videoFile.exists()) {
                    videoFile.delete()
                }
                response.close()
                
                // Если выбраны контакты, отправляем сообщение каждому из них
                if (selectedContacts.isNotEmpty() && telegramUserId != null) {
                    // Здесь должна быть логика отправки сообщений контактам
                    // Но сейчас у нас нет реальной интеграции с Telegram API для этого
                }
            } catch (e: Exception) {
                Log.e("MainActivity", "Network error while sending video: ${e.message}")
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(stopReceiver)
        ioScope.cancel()
        stop()
        
        // Освобождаем ресурсы TDLib
        if (::telegramAuthHelper.isInitialized) {
            telegramAuthHelper.release()
        }
    }

    private suspend fun getFreshLocation(): android.location.Location? {
        val fused = LocationServices.getFusedLocationProviderClient(this)
        return fused.getCurrentLocation(Priority.PRIORITY_BALANCED_POWER_ACCURACY, /* cancellationToken = */ null).await()
    }

    private fun startLiveLocation() {
        ioScope.launch {
            while (MainActivity.isActive) {
                sendLiveLocation()
                delay(60_000)   // 1 минута
            }
        }
    }

    private fun sendLiveLocation(){
        ioScope.launch {
            try {
                val location = getFreshLocation()
                if (liveLocationMessageId == null) {
                    val url = "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}" +
                            "/sendLocation?chat_id=${TELEGRAM_CHAT_ID}" +
                            "&latitude=${location?.latitude}" +
                            "&longitude=${location?.longitude}" +
                            "&live_period=${86400}"
                    val response =
                        OkHttpClient().newCall(Request.Builder().url(url).get().build()).execute()
                    val responseBody = response.body?.string()
                    if (responseBody != null) {
                        val messageIdRegex = """"message_id":(\d+)""".toRegex()
                        val matchResult = messageIdRegex.find(responseBody)
                        if (matchResult != null && matchResult.groupValues.size > 1) {
                            liveLocationMessageId = matchResult.groupValues[1].toInt()
                        }
                    }
                    response.close()
                } else {
                    val url = "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}" +
                            "/editMessageLiveLocation" +
                            "?chat_id=${TELEGRAM_CHAT_ID}" +
                            "&message_id=${liveLocationMessageId}" +
                            "&latitude=${location?.latitude}" +
                            "&longitude=${location?.longitude}"
                    OkHttpClient().newCall(Request.Builder().url(url).get().build()).execute().close()
                }
            } catch (e: Exception) {
                Log.e("MainActivity", "Live location update failed: ${e.message}")
            }
        }
    }

    private fun loadRtmpSettings() {
        val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
        rtmpUrl = sharedPrefs.getString("rtmp_url", "").toString()
        rtmpStreamKey = sharedPrefs.getString("rtmp_stream_key", "").toString()
        fullRtmpUrl = "$rtmpUrl/$rtmpStreamKey"
    }

    private fun showRtmpSettingsDialog(returnToMainMenu: Boolean = false) {
        // Отображаем диалог с прогрессбаром пока загружаем каналы
        val progressDialog = ProgressDialog(this).apply {
            setMessage("Загрузка списка каналов...")
            setCancelable(false)
            show()
        }
        
        // Загружаем список каналов
        fetchChannelsFromSheet { success ->
            progressDialog.dismiss()
            
            if (success && channelsList.isNotEmpty()) {
                showChannelSelectionDialog(returnToMainMenu)
            } else {
                Toast.makeText(this, "Не удалось загрузить список каналов", Toast.LENGTH_LONG).show()
                // Если не удалось загрузить каналы, но нужно вернуться в основное меню
                if (returnToMainMenu) {
                    showSettingsDialog()
                }
            }
        }
    }
    
    private fun fetchChannelsFromSheet(callback: (Boolean) -> Unit) {
        channelsList.clear()
        
        ioScope.launch {
            try {
                val client = OkHttpClient()
                val request = Request.Builder()
                    .url(SPREADSHEET_URL)
                    .build()
                
                val response = client.newCall(request).execute()
                val csvData = response.body?.string()
                
                if (csvData != null) {
                    // Обрабатываем CSV данные
                    val lines = csvData.lines()
                    // Пропускаем заголовок (первую строку)
                    for (i in 1 until lines.size) {
                        val line = lines[i].trim()
                        if (line.isNotEmpty()) {
                            val columns = line.split(",")
                            if (columns.size >= 3) {
                                val name = columns[0].trim()
                                val url = columns[1].trim()
                                val key = columns[2].trim()
                                channelsList.add(ChannelInfo(name, url, key))
                            }
                        }
                    }
                    
                    withContext(Dispatchers.Main) {
                        callback(true)
                    }
                } else {
                    withContext(Dispatchers.Main) {
                        callback(false)
                    }
                }
            } catch (e: Exception) {
                Log.e("MainActivity", "Ошибка при загрузке каналов: ${e.message}")
                withContext(Dispatchers.Main) {
                    callback(false)
                }
            }
        }
    }
    
    private fun showChannelSelectionDialog(returnToMainMenu: Boolean = false) {
        val dialogLayout = LinearLayout(this)
        dialogLayout.orientation = LinearLayout.VERTICAL
        dialogLayout.setPadding(50, 30, 50, 30)

        // Заголовок
        val titleTextView = TextView(this)
        titleTextView.text = "Выберите канал"
        titleTextView.textSize = 18f
        titleTextView.setPadding(0, 0, 0, 30)
        dialogLayout.addView(titleTextView)

        // Создаем адаптер с названиями каналов
        val channelNames = channelsList.map { it.name }.toTypedArray()
        val adapter = ArrayAdapter(this, android.R.layout.simple_list_item_single_choice, channelNames)
        
        // Список каналов
        val listView = ListView(this)
        listView.adapter = adapter
        listView.choiceMode = ListView.CHOICE_MODE_SINGLE
        
        // Находим текущий выбранный канал
        var selectedChannelIndex = -1
        for (i in channelsList.indices) {
            if (channelsList[i].url == rtmpUrl && channelsList[i].key == rtmpStreamKey) {
                selectedChannelIndex = i
                break
            }
        }
        
        // Выделяем текущий канал если он найден
        if (selectedChannelIndex >= 0) {
            listView.setItemChecked(selectedChannelIndex, true)
        }
        
        dialogLayout.addView(listView)

        // Создаем и отображаем диалог
        val dialog = androidx.appcompat.app.AlertDialog.Builder(this)
            .setView(dialogLayout)
            .setPositiveButton("Сохранить") { _, _ ->
                val checkedPosition = listView.checkedItemPosition
                if (checkedPosition != ListView.INVALID_POSITION) {
                    val selectedChannel = channelsList[checkedPosition]
                    rtmpUrl = selectedChannel.url
                    rtmpStreamKey = selectedChannel.key
                    fullRtmpUrl = "$rtmpUrl/$rtmpStreamKey"
                    
                    // Сохраняем настройки
                    val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
                    sharedPrefs.edit()
                        .putString("rtmp_url", rtmpUrl)
                        .putString("rtmp_stream_key", rtmpStreamKey)
                        .putString("channel_name", selectedChannel.name) // Сохраняем название канала
                        .apply()
                    
                    Toast.makeText(this, "Выбран канал: ${selectedChannel.name}", Toast.LENGTH_SHORT).show()
                    
                    // Возвращаемся в основное меню настроек если нужно
                    if (returnToMainMenu) {
                        showSettingsDialog()
                    }
                }
            }
            .setNegativeButton("Отмена") { _, _ ->
                // Возвращаемся в основное меню настроек если нужно
                if (returnToMainMenu) {
                    showSettingsDialog()
                }
            }
            .create()
        
        // Центрирование заголовка
        dialog.setOnShowListener {
            val titleView = dialog.findViewById<TextView>(android.R.id.title)
            titleView?.gravity = android.view.Gravity.CENTER
        }
        
        dialog.show()
    }

    override fun onPictureInPictureModeChanged(isInPictureInPictureMode: Boolean, newConfig: Configuration) {
        super.onPictureInPictureModeChanged(isInPictureInPictureMode, newConfig)
        if (isInPictureInPictureMode) {
            root.alpha = 0f
        } else {
            root.alpha = 1f
        }
    }

    private suspend fun <T> Task<T>.await(): T? {
        return suspendCancellableCoroutine { continuation ->
            this.addOnCompleteListener { task ->
                if (task.isSuccessful) {
                    continuation.resume(task.result, null)
                } else {
                    continuation.resume(null, null)
                }
            }
        }
    }

    override fun onConnectionStarted(url: String) {
        Log.d("MainActivity", "RTMP соединение начато: $url")
    }

    override fun onAuthError() {
        Log.e("MainActivity", "Ошибка авторизации RTMP")
    }

    override fun onAuthSuccess() {
        Log.d("MainActivity", "Успешная авторизация RTMP")
    }

    override fun onDisconnect() {
        Log.d("MainActivity", "RTMP соединение закрыто")
    }

    override fun onConnectionSuccess() {
        Log.d("MainActivity", "RTMP соединение успешно установлено")
    }

    override fun onConnectionFailed(reason: String) {
        Log.e("MainActivity", "RTMP соединение прервано: $reason")
    }

    // Метод для запуска авторизации в Telegram
    private fun startTelegramAuth() {
        // Показываем диалог авторизации через TDLib
        TelegramAuthDialogs.showTelegramLoginDialog(
            context = this,
            authHelper = telegramAuthHelper,
            onAuthSuccess = { userData ->
                // Успешная авторизация через TDLib
                telegramUserId = userData.id
                telegramUserName = "${userData.first_name}${userData.last_name?.let { " $it" } ?: ""}"
                telegramUserPhone = userData.phone_number
                
                // Сохраняем данные в SharedPreferences
                val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
                sharedPrefs.edit()
                    .putLong("telegram_user_id", userData.id)
                    .putString("telegram_user_name", telegramUserName)
                    .putString("telegram_username", userData.username)
                    .putString("telegram_phone", userData.phone_number)
                    .apply()
                
                Toast.makeText(this, "Успешная авторизация через Telegram! Добро пожаловать, ${userData.first_name}!", Toast.LENGTH_SHORT).show()
                
                // Загружаем контакты
                loadTelegramContacts()
                
                // Обновляем диалог настроек
                showSettingsDialog()
            },
            onAuthError = { error ->
                // Ошибка авторизации
                TelegramAuthDialogs.showAuthErrorDialog(this, error) {
                    // Повторная попытка
                    startTelegramAuth()
                }
            }
        )
    }
    
    // Метод для загрузки контактов
    private fun loadTelegramContacts() {
        telegramAuthHelper.getContacts { contacts ->
            // Обновляем список контактов
            telegramContacts.clear()
            contacts.forEach { contact ->
                telegramContacts.add(
                    TelegramContact(
                        id = contact.id,
                        name = contact.name,
                        phone = contact.phone
                    )
                )
            }
            
            // Загружаем выбранные контакты из настроек
            val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
            val selectedContactIds = sharedPrefs.getString("selected_contacts", "")?.split(",")?.mapNotNull { 
                it.toLongOrNull() 
            } ?: listOf()
            
            // Восстанавливаем выбранные контакты
            selectedContacts.clear()
            for (contact in telegramContacts) {
                if (selectedContactIds.contains(contact.id)) {
                    selectedContacts.add(contact)
                }
            }
        }
    }

    // Метод для выхода из аккаунта Telegram
    private fun logoutFromTelegram() {
        TelegramAuthDialogs.showLogoutConfirmDialog(this) {
            telegramAuthHelper.logout()
            
            // Очищаем локальные данные
            telegramUserId = null
            telegramUserName = null
            telegramUserPhone = null
            telegramContacts.clear()
            selectedContacts.clear()
            
            val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
            sharedPrefs.edit()
                .remove("telegram_user_id")
                .remove("telegram_user_name")
                .remove("telegram_user_phone")
                .remove("selected_contacts")
                .apply()
            
            Toast.makeText(this, "Выход выполнен", Toast.LENGTH_SHORT).show()
            showSettingsDialog()
        }
    }

    // Метод для показа диалога выбора контактов
    private fun showContactsSelectionDialog() {
        if (telegramContacts.isEmpty()) {
            Toast.makeText(this, "Контакты не найдены", Toast.LENGTH_SHORT).show()
            return
        }
        
        val dialogLayout = LinearLayout(this)
        dialogLayout.orientation = LinearLayout.VERTICAL
        dialogLayout.setPadding(50, 30, 50, 30)
        
        // Заголовок
        val titleTextView = TextView(this)
        titleTextView.text = "Выберите контакты"
        titleTextView.textSize = 18f
        titleTextView.setPadding(0, 0, 0, 30)
        dialogLayout.addView(titleTextView)
        
        // Создаем список контактов с чекбоксами
        val contactsListView = ListView(this)
        val contactItems = Array(telegramContacts.size) { i -> telegramContacts[i].name }
        
        // Адаптер с множественным выбором
        val adapter = ArrayAdapter(this, android.R.layout.simple_list_item_multiple_choice, contactItems)
        contactsListView.adapter = adapter
        contactsListView.choiceMode = ListView.CHOICE_MODE_MULTIPLE
        
        // Отмечаем ранее выбранные контакты
        for (i in telegramContacts.indices) {
            val contact = telegramContacts[i]
            if (selectedContacts.any { it.id == contact.id }) {
                contactsListView.setItemChecked(i, true)
            }
        }
        
        dialogLayout.addView(contactsListView)
        
        // Создаем и отображаем диалог
        val dialog = androidx.appcompat.app.AlertDialog.Builder(this)
            .setView(dialogLayout)
            .setPositiveButton("Сохранить") { _, _ ->
                // Сохраняем выбранные контакты
                selectedContacts.clear()
                for (i in 0 until contactsListView.count) {
                    if (contactsListView.isItemChecked(i)) {
                        selectedContacts.add(telegramContacts[i])
                    }
                }
                
                // Сохраняем ID выбранных контактов
                val selectedIds = selectedContacts.map { it.id }.toLongArray()
                val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
                sharedPrefs.edit()
                    .putString("selected_contacts", selectedIds.joinToString(","))
                    .apply()
                
                // Возвращаемся в диалог настроек
                showSettingsDialog()
            }
            .setNegativeButton("Отмена") { _, _ ->
                // Ничего не делаем, просто закрываем диалог
            }
            .create()
        
        // Центрирование заголовка
        dialog.setOnShowListener {
            val titleView = dialog.findViewById<TextView>(android.R.id.title)
            titleView?.gravity = android.view.Gravity.CENTER
        }
        
        dialog.show()
    }

    // Инициализация Telegram авторизации (вызывается только один раз)
    private fun initializeTelegramAuth() {
        // Инициализируем TelegramAuthHelper с колбэком
        telegramAuthHelper.init(object : TelegramAuthHelper.AuthCallback {
            override fun onAuthStateChanged(state: TelegramAuthHelper.AuthState) {
                when (state) {
                    TelegramAuthHelper.AuthState.AUTHENTICATED -> {
                        // Пользователь уже авторизован, загружаем его данные
                        val userData = telegramAuthHelper.getCurrentUserInfo()
                        if (userData != null) {
                            telegramUserId = userData.id
                            telegramUserName = "${userData.first_name}${userData.last_name?.let { " $it" } ?: ""}"
                            telegramUserPhone = userData.phone_number
                            
                            // Загружаем контакты
                            loadTelegramContacts()
                        }
                    }
                    TelegramAuthHelper.AuthState.NOT_AUTHENTICATED -> {
                        // Пользователь не авторизован
                        telegramUserId = null
                        telegramUserName = null
                        telegramUserPhone = null
                        telegramContacts.clear()
                        selectedContacts.clear()
                    }
                    TelegramAuthHelper.AuthState.ERROR -> {
                        // Ошибка авторизации, очищаем данные
                        telegramUserId = null
                        telegramUserName = null
                        telegramUserPhone = null
                        telegramContacts.clear()
                        selectedContacts.clear()
                    }
                    TelegramAuthHelper.AuthState.WAIT_ENCRYPTION_KEY -> {
                        // Ожидание установки ключа шифрования (автоматически)
                    }
                    else -> {
                        // Другие состояния (ожидание ввода телефона, кода, пароля)
                    }
                }
            }
            
            override fun onContactsReceived(contacts: List<TelegramAuthHelper.TelegramContact>) {
                // Обновляем список контактов
                telegramContacts.clear()
                contacts.forEach { contact ->
                    telegramContacts.add(
                        TelegramContact(
                            id = contact.id,
                            name = contact.name,
                            phone = contact.phone
                        )
                    )
                }
                
                // Загружаем выбранные контакты из настроек
                val sharedPrefs = getSharedPreferences("taxi_sos_prefs", Context.MODE_PRIVATE)
                val selectedContactIds = sharedPrefs.getString("selected_contacts", "")?.split(",")?.mapNotNull { 
                    it.toLongOrNull() 
                } ?: listOf()
                
                // Восстанавливаем выбранные контакты
                selectedContacts.clear()
                for (contact in telegramContacts) {
                    if (selectedContactIds.contains(contact.id)) {
                        selectedContacts.add(contact)
                    }
                }
            }
            
            override fun onUserDataReceived(userData: TelegramAuthHelper.TelegramAuthData) {
                // Обновляем данные пользователя
                telegramUserId = userData.id
                telegramUserName = "${userData.first_name}${userData.last_name?.let { " $it" } ?: ""}"
                telegramUserPhone = userData.phone_number
            }
            
            override fun onError(error: String) {
                Log.e("MainActivity", "Ошибка TDLib: $error")
            }
        })
    }

    // Добавим метод для проверки разрешений перед запуском авторизации
    private fun checkTelegramAuthPermissions() {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
            val permissions = arrayOf(
                android.Manifest.permission.READ_CONTACTS,
                android.Manifest.permission.READ_PHONE_STATE,
                android.Manifest.permission.READ_EXTERNAL_STORAGE,
                android.Manifest.permission.WRITE_EXTERNAL_STORAGE
            )
            
            val missingPermissions = permissions.filter {
                checkSelfPermission(it) != android.content.pm.PackageManager.PERMISSION_GRANTED
            }.toTypedArray()
            
            if (missingPermissions.isNotEmpty()) {
                requestPermissions(missingPermissions, TELEGRAM_AUTH_PERMISSION_REQUEST_CODE)
            } else {
                // Все разрешения уже предоставлены, запускаем авторизацию
                startTelegramAuth()
            }
        } else {
            // Для API < 23 разрешения уже предоставлены в манифесте
            startTelegramAuth()
        }
    }

    // Обработка результата запроса разрешений
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        
        when (requestCode) {
            TELEGRAM_AUTH_PERMISSION_REQUEST_CODE -> {
                if (grantResults.isNotEmpty() && grantResults.all { it == android.content.pm.PackageManager.PERMISSION_GRANTED }) {
                    // Все необходимые разрешения получены
                    startTelegramAuth()
                } else {
                    Toast.makeText(this, "Для авторизации необходимы все запрошенные разрешения", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    
    // Тестирование новой официальной TDLib
    private fun testOfficialTdLib() {
        // Запускаем тесты в отдельном потоке
        Thread {
            TdLibTest.runTests(this)
        }.start()
    }
}