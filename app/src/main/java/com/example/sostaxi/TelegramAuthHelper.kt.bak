package com.example.sostaxi

import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import org.drinkless.td.libcore.telegram.Client
import org.drinkless.td.libcore.telegram.TdApi

class TelegramAuthHelper(private val context: Context) {
    
    companion object {
        private const val TAG = "TelegramAuthHelper"
        private const val PREFS_NAME = "telegram_auth_prefs"
        
        // ВАЖНО: Замените эти значения на ваши собственные из https://my.telegram.org/apps
        // Текущие значения предназначены только для тестирования!
        private const val API_ID = 27274131  // ЗАМЕНИТЕ НА ВАШ API ID
        private const val API_HASH = "ade6f43cffd569b9ff1f0b7e21bad4df"  // ЗАМЕНИТЕ НА ВАШ API HASH
    }
    
    private var client: Client? = null
    private val sharedPrefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    private var authCallback: AuthCallback? = null
    private var isInitialized = false
    
    // Состояния авторизации
    enum class AuthState {
        NOT_AUTHENTICATED,
        WAIT_ENCRYPTION_KEY,
        WAIT_PHONE_NUMBER,
        WAIT_CODE,
        WAIT_PASSWORD,
        AUTHENTICATED,
        ERROR
    }
    
    // Интерфейс для обратных вызовов
    interface AuthCallback {
        fun onAuthStateChanged(state: AuthState)
        fun onContactsReceived(contacts: List<TelegramContact>)
        fun onUserDataReceived(userData: TelegramAuthData)
        fun onError(error: String)
    }
    
    // Данные пользователя Telegram
    data class TelegramAuthData(
        val id: Long,
        val first_name: String,
        val last_name: String?,
        val username: String?,
        val phone_number: String?
    )
    
    // Контакт Telegram
    data class TelegramContact(
        val id: Long,
        val name: String,
        val phone: String,
        val username: String?
    )
    
    private var currentAuthState = AuthState.NOT_AUTHENTICATED
    private var currentUser: TelegramAuthData? = null
    private val contactsList = mutableListOf<TelegramContact>()
    private var useTestDc = false // По умолчанию используем продакшн серверы
    
    fun init(callback: AuthCallback) {
        // Предотвращаем множественную инициализацию
        if (isInitialized) {
            Log.w(TAG, "TelegramAuthHelper уже инициализирован")
            this.authCallback = callback
            // Если уже авторизованы, сразу уведомляем об этом
            if (currentAuthState == AuthState.AUTHENTICATED) {
                callback.onAuthStateChanged(currentAuthState)
                currentUser?.let { callback.onUserDataReceived(it) }
                if (contactsList.isNotEmpty()) {
                    callback.onContactsReceived(contactsList.toList())
                }
            }
            return
        }
        
        this.authCallback = callback
        
        try {
            // Освобождаем предыдущий клиент, если он существует
            client?.close()
            
            // Инициализируем TDLib клиент
            client = Client.create(
                { update -> handleUpdate(update) },
                null,
                null
            )
            
            isInitialized = true
            Log.d(TAG, "TDLib клиент инициализирован")
        } catch (e: Exception) {
            Log.e(TAG, "Ошибка инициализации TDLib: ${e.message}")
            authCallback?.onError("Ошибка инициализации: ${e.message}")
        }
    }
    
    private fun handleUpdate(update: TdApi.Object) {
        when (update) {
            is TdApi.UpdateAuthorizationState -> {
                handleAuthorizationState(update.authorizationState)
            }
            is TdApi.UpdateUser -> {
                if (update.user.id.toLong() == getCurrentUserId()) {
                    updateCurrentUser(update.user)
                }
            }
            is TdApi.UpdateUserStatus -> {
                // Обновление статуса пользователя
            }
            else -> {
                // Другие обновления
            }
        }
    }
    
    private fun handleAuthorizationState(authState: TdApi.AuthorizationState) {
        Log.d(TAG, "Состояние авторизации: ${authState.javaClass.simpleName}")
        when (authState) {
            is TdApi.AuthorizationStateWaitTdlibParameters -> {
                // Настройка параметров TDLib
                val databaseDir = context.filesDir.absolutePath + "/tdlib"
                val databaseFile = java.io.File(databaseDir)
                if (!databaseFile.exists()) {
                    databaseFile.mkdirs()
                }
                
                val parameters = TdApi.TdlibParameters().apply {
                    databaseDirectory = databaseDir
                    filesDirectory = ""
                    useFileDatabase = false
                    useChatInfoDatabase = false
                    useMessageDatabase = true
                    useSecretChats = true
                    apiId = API_ID
                    apiHash = API_HASH
                    systemLanguageCode = "ru"
                    deviceModel = android.os.Build.MODEL
                    systemVersion = android.os.Build.VERSION.RELEASE
                    applicationVersion = "1.6.0"
                    enableStorageOptimizer = true
                    ignoreFileNames = false
                    // Используем продакшн серверы (false = продакшн, true = тест)
                    useTestDc = this@TelegramAuthHelper.useTestDc
                }
                
                sendQuery(TdApi.SetTdlibParameters(parameters)) { result ->
                    if (result is TdApi.Error) {
                        Log.e(TAG, "Ошибка установки параметров: ${result.message}")
                        if (result.message.contains("already in use")) {
                            // Пытаемся очистить заблокированные файлы
                            clearTdlibDatabase()
                            // Повторяем попытку через небольшую задержку
                            android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({
                                sendQuery(TdApi.SetTdlibParameters(parameters)) { retryResult ->
                                    if (retryResult is TdApi.Error) {
                                        authCallback?.onError("Ошибка настройки: ${retryResult.message}")
                                    }
                                }
                            }, 1000)
                        } else {
                            authCallback?.onError("Ошибка настройки: ${result.message}")
                        }
                    }
                }
            }
            
            is TdApi.AuthorizationStateWaitEncryptionKey -> {
                currentAuthState = AuthState.WAIT_ENCRYPTION_KEY
                authCallback?.onAuthStateChanged(currentAuthState)
                
                // Устанавливаем ключ шифрования базы данных (пустой для незашифрованной БД)
                sendQuery(TdApi.CheckDatabaseEncryptionKey()) { result ->
                    if (result is TdApi.Error) {
                        Log.e(TAG, "Ошибка установки ключа шифрования: ${result.message}")
                        authCallback?.onError("Ошибка ключа шифрования: ${result.message}")
                    }
                }
            }
            
            is TdApi.AuthorizationStateWaitPhoneNumber -> {
                currentAuthState = AuthState.WAIT_PHONE_NUMBER
                authCallback?.onAuthStateChanged(currentAuthState)
            }
            
            is TdApi.AuthorizationStateWaitCode -> {
                currentAuthState = AuthState.WAIT_CODE
                authCallback?.onAuthStateChanged(currentAuthState)
            }
            
            is TdApi.AuthorizationStateWaitPassword -> {
                currentAuthState = AuthState.WAIT_PASSWORD
                authCallback?.onAuthStateChanged(currentAuthState)
            }
            
            is TdApi.AuthorizationStateReady -> {
                currentAuthState = AuthState.AUTHENTICATED
                authCallback?.onAuthStateChanged(currentAuthState)
                
                // Получаем информацию о текущем пользователе
                sendQuery(TdApi.GetMe()) { result ->
                    if (result is TdApi.User) {
                        updateCurrentUser(result)
                        // Загружаем контакты
                        loadContacts()
                    }
                }
            }
            
            is TdApi.AuthorizationStateLoggingOut -> {
                currentAuthState = AuthState.NOT_AUTHENTICATED
                authCallback?.onAuthStateChanged(currentAuthState)
            }
            
            is TdApi.AuthorizationStateClosing -> {
                currentAuthState = AuthState.NOT_AUTHENTICATED
                authCallback?.onAuthStateChanged(currentAuthState)
            }
            
            is TdApi.AuthorizationStateClosed -> {
                currentAuthState = AuthState.NOT_AUTHENTICATED
                authCallback?.onAuthStateChanged(currentAuthState)
                isInitialized = false
            }
        }
    }
    
    // Очистка базы данных TDLib
    private fun clearTdlibDatabase() {
        try {
            val databaseDir = java.io.File(context.filesDir.absolutePath + "/tdlib")
            if (databaseDir.exists()) {
                databaseDir.listFiles()?.forEach { file ->
                    if (file.name.contains("binlog") || file.name.contains("db")) {
                        try {
                            file.delete()
                            Log.d(TAG, "Удален файл: ${file.name}")
                        } catch (e: Exception) {
                            Log.w(TAG, "Не удалось удалить файл ${file.name}: ${e.message}")
                        }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Ошибка очистки базы данных: ${e.message}")
        }
    }
    
    private fun updateCurrentUser(user: TdApi.User) {
        currentUser = TelegramAuthData(
            id = user.id.toLong(),
            first_name = user.firstName,
            last_name = user.lastName.takeIf { it.isNotEmpty() },
            username = user.username.takeIf { it.isNotEmpty() },
            phone_number = user.phoneNumber.takeIf { it.isNotEmpty() }
        )
        
        currentUser?.let { userData ->
            authCallback?.onUserDataReceived(userData)
            
            // Сохраняем данные пользователя
            sharedPrefs.edit()
                .putLong("user_id", userData.id)
                .putString("first_name", userData.first_name)
                .putString("last_name", userData.last_name)
                .putString("username", userData.username)
                .putString("phone_number", userData.phone_number)
                .apply()
        }
    }
    
    // Проверка, является ли номер тестовым
    private fun isTestPhoneNumber(phoneNumber: String): Boolean {
        val cleanPhone = phoneNumber.replace(Regex("[^+\\d]"), "")
        return cleanPhone.startsWith("+999661222") // Тестовые номера Telegram
    }

    // Отправка номера телефона
    fun sendPhoneNumber(phoneNumber: String) {
        val cleanPhone = phoneNumber.replace(Regex("[^+\\d]"), "")
        Log.d(TAG, "Отправка номера телефона: $cleanPhone")
        
        // Проверяем совместимость номера и серверов
        if (useTestDc && !isTestPhoneNumber(cleanPhone)) {
            Log.w(TAG, "Внимание: используется реальный номер с тестовыми серверами")
            authCallback?.onError("Для тестовых серверов используйте тестовые номера:\n+9996612222 (код: 22222)\n+9996612223 (код: 22223)\n+9996612224 (код: 22224)")
            return
        } else if (!useTestDc && isTestPhoneNumber(cleanPhone)) {
            Log.w(TAG, "Внимание: используется тестовый номер с продакшн серверами")
            authCallback?.onError("Тестовые номера не работают с продакшн серверами.\nИспользуйте реальный номер телефона в формате +7XXXXXXXXXX")
            return
        }
        
        sendQuery(TdApi.SetAuthenticationPhoneNumber(cleanPhone, null)) { result ->
            if (result is TdApi.Error) {
                Log.e(TAG, "Ошибка отправки номера телефона: код=${result.code}, сообщение=${result.message}")
                
                when {
                    result.code == 406 && result.message == "UPDATE_APP_TO_LOGIN" -> {
                        Log.e(TAG, "Ошибка UPDATE_APP_TO_LOGIN с TDLib 1.8.0 - проверьте API ключи")
                        authCallback?.onError("Ошибка авторизации. Проверьте правильность API ключей и номера телефона.\n\nДля продакшн серверов используйте собственные API ключи с https://my.telegram.org/apps")
                    }
                    result.code == 400 && result.message.contains("PHONE_NUMBER_INVALID") -> {
                        val errorMessage = if (useTestDc) {
                            "Неверный формат номера телефона для тестовых серверов.\nИспользуйте: +9996612222, +9996612223 или +9996612224"
                        } else {
                            "Неверный формат номера телефона для продакшн серверов.\nИспользуйте реальный номер в международном формате: +7XXXXXXXXXX"
                        }
                        authCallback?.onError(errorMessage)
                    }
                    else -> {
                        authCallback?.onError("Ошибка отправки номера: ${result.message}")
                    }
                }
            } else {
                Log.d(TAG, "Номер телефона отправлен успешно")
            }
        }
    }
    
    // Отправка кода подтверждения
    fun sendVerificationCode(code: String) {
        sendQuery(TdApi.CheckAuthenticationCode(code)) { result ->
            if (result is TdApi.Error) {
                Log.e(TAG, "Ошибка проверки кода: ${result.message}")
                authCallback?.onError("Неверный код: ${result.message}")
            }
        }
    }
    
    // Отправка пароля двухфакторной аутентификации
    fun sendPassword(password: String) {
        sendQuery(TdApi.CheckAuthenticationPassword(password)) { result ->
            if (result is TdApi.Error) {
                Log.e(TAG, "Ошибка проверки пароля: ${result.message}")
                authCallback?.onError("Неверный пароль: ${result.message}")
            }
        }
    }
    
    // Загрузка контактов
    private fun loadContacts() {
        sendQuery(TdApi.GetContacts()) { result ->
            if (result is TdApi.Users) {
                contactsList.clear()
                
                // Получаем информацию о каждом контакте
                result.userIds.forEach { userId ->
                    sendQuery(TdApi.GetUser(userId)) { userResult ->
                        if (userResult is TdApi.User) {
                            val contact = TelegramContact(
                                id = userResult.id.toLong(),
                                name = "${userResult.firstName} ${userResult.lastName}".trim(),
                                phone = userResult.phoneNumber,
                                username = userResult.username.takeIf { it.isNotEmpty() }
                            )
                            contactsList.add(contact)
                            
                            // Уведомляем о получении контактов
                            authCallback?.onContactsReceived(contactsList.toList())
                        }
                    }
                }
            } else if (result is TdApi.Error) {
                Log.e(TAG, "Ошибка загрузки контактов: ${result.message}")
                authCallback?.onError("Ошибка загрузки контактов: ${result.message}")
            }
        }
    }
    
    // Получение контактов (публичный метод)
    fun getContacts(callback: (List<TelegramContact>) -> Unit) {
        if (contactsList.isNotEmpty()) {
            callback(contactsList.toList())
        } else {
            loadContacts()
            // Контакты будут переданы через AuthCallback.onContactsReceived
        }
    }
    
    // Получение текущего пользователя
    fun getCurrentUserInfo(): TelegramAuthData? {
        return currentUser
    }
    
    // Получение ID текущего пользователя
    private fun getCurrentUserId(): Long {
        return sharedPrefs.getLong("user_id", 0)
    }
    
    // Выход из аккаунта
    fun logout() {
        sendQuery(TdApi.LogOut()) { result ->
            if (result is TdApi.Ok) {
                // Очищаем сохраненные данные
                sharedPrefs.edit().clear().apply()
                currentUser = null
                contactsList.clear()
                currentAuthState = AuthState.NOT_AUTHENTICATED
                authCallback?.onAuthStateChanged(currentAuthState)
            } else if (result is TdApi.Error) {
                Log.e(TAG, "Ошибка выхода: ${result.message}")
                authCallback?.onError("Ошибка выхода: ${result.message}")
            }
        }
    }
    
    // Отправка запроса к TDLib
    private fun sendQuery(query: TdApi.Function, handler: (TdApi.Object) -> Unit) {
        client?.send(query, handler)
    }
    
    // Освобождение ресурсов
    fun release() {
        try {
            client?.close()
            client = null
        } catch (e: Exception) {
            Log.e(TAG, "Ошибка при освобождении ресурсов: ${e.message}")
        }
    }
    
    // Проверка состояния авторизации
    fun isAuthenticated(): Boolean {
        return currentAuthState == AuthState.AUTHENTICATED
    }
    
    // Получение текущего состояния авторизации
    fun getCurrentAuthState(): AuthState {
        return currentAuthState
    }
    
    // Переключение между тестовыми и продакшн серверами
    fun setUseTestServers(useTest: Boolean) {
        if (useTestDc != useTest) {
            useTestDc = useTest
            // Если клиент уже инициализирован, нужно перезапустить
            if (isInitialized) {
                Log.d(TAG, "Переключение серверов, перезапуск клиента...")
                release()
                isInitialized = false
                authCallback?.let { init(it) }
            }
        }
    }
    
    // Проверка, используются ли тестовые серверы
    fun isUsingTestServers(): Boolean {
        return useTestDc
    }
} 